////////////////////////////////////////////////////
//
// Enums
//
////////////////////////////////////////////////////

enum pickupDropFlags {
    pdf_unknown1    = 0,
    pdf_unknown2,
    pdf_health_full,
    pdf_unknown4,
    pdf_health_small,
    pdf_health_medium
}

////////////////////////////////////////////////////
//
// TurokAI
//
////////////////////////////////////////////////////

class TurokAI : Component {
    kActor @self;
    kAI @ai;
    int alligenceID;
    int dropItemFlags;
    bool bDeathFade;
    float deathFadeTime;
    float baseYawSpeed;
    
    //
    // TurokAI::TurokAI
    //
    
    TurokAI(kActor @actor) {
        @self = actor;
        @ai = self.ToAI();
        
        alligenceID = -1;
        dropItemFlags = 0;
        bDeathFade = false;
        deathFadeTime = 0.0f;
        baseYawSpeed = 2.0f;
    }
    
    //
    // TurokAI::PickAnimSet
    //
    
    void PickAnimSet(const array<int> &anims, const array<int> &weights) {
        if(anims.length() != weights.length()) {
            return;
        }
        
        int randomSum = 0;
        uint i;
        int count = 0;
        array<int>rndArray;
        
        for(i = 0; i < weights.length(); i++) {
            if(self.AnimState().CheckAnimID(anims[i])) {
                rndArray.insertLast(randomSum);
                randomSum += weights[i];
                count++;
            }
        }
        
        if(randomSum == 0 || count == 0) {
            return;
        }
        
        int r = Math::RandMax(randomSum);
        
        for(i = count-1; i >= 0; i--) {
            if(rndArray[i] <= r) {
                break;
            }
        }
        
        self.AnimState().Blend(anims[i], 4.0f, 8.0f, ANF_ROOTMOTION);
    }
    
    //
    // TurokAI::DropPickup
    //
    
    void DropPickup(const float x, const float y, const float z, const kStr itemName) {
        kVec3 origin = self.ToLocalOrigin(x, y, z);
        origin.y += 8.192f;
        
        kActor @actor = LocalWorld.SpawnActor(itemName, origin, self.GetAngles());
        
        actor.bCollision = false;
        
        actor.Physics().bEnabled = true;
        actor.Physics().friction = 0.5f;
        actor.Physics().bounceDamp = 0.35f;
        actor.Physics().airFriction = 0.0f;
        actor.Physics().fallFriction = 0.0f;
        
        kVec3 velocity(0.0f, 1.0f, 0.0f);
        kVec3 rVector(Math::RandCFloat(),
                      Math::RandCFloat(),
                      Math::RandCFloat());
                      
        velocity.Lerp(rVector, 0.25f);
        actor.Physics().GetVelocity() = velocity.Normalize() * 409.6f;
    }
    
    //
    // TurokAI::CheckDropPickupFlags
    //
    
    const bool CheckDropPickupFlags(const int flag) {
        return (dropItemFlags & (1 << flag)) != 0;
    }
    
    //
    // TurokAI::spawnItem
    //
    
    void spawnItem(const float x, const float y, const float z) {
        if(CheckDropPickupFlags(pdf_health_small)) {
            DropPickup(x, y, z, "defs/actors.def@Item_Health_Small");
        }
    }
    
    //
    // TurokAI::OnStateChange
    //
    
    void OnStateChange(int state) {
        switch(state) {
            case AIS_IDLE:
                self.AnimState().Blend(anim_aiStanding, 4.0f, 8.0f, ANF_LOOP);
                ai.bAnimTurning = false;
                break;
                
            case AIS_CALM:
                if(ai.bAnimTurning == true) {
                    if(ShouldKeepTurning()) {
                        break;
                    }
                    else {
                        ai.bAnimTurning = false;
                    }
                }
                self.AnimState().Blend(anim_aiWalking, 4.0f, 8.0f, ANF_ROOTMOTION|ANF_LOOP);
                break;
                
            case AIS_ALERT:
                if(ai.bAnimTurning == true) {
                    if(ShouldKeepTurning()) {
                        break;
                    }
                    else {
                        ai.bAnimTurning = false;
                    }
                }
                self.AnimState().Blend(anim_aiRunning, 4.0f, 8.0f, ANF_ROOTMOTION|ANF_LOOP);
                break;
                
            case AIS_ATTACK_MELEE:
                self.AnimState().Blend(anim_aiMelee2, 4.0f, 8.0f, ANF_ROOTMOTION);
                ai.bAnimTurning = false;
                break;
                
            case AIS_ATTACK_RANGE:
                ai.SetIdealYaw(self.GetAngles().yaw + ai.GetYawToTarget(), 4.096f);
                self.AnimState().Blend(anim_aiRangeAttack2, 4.0f, 8.0f, ANF_ROOTMOTION);
                ai.bAnimTurning = false;
                break;
        }
    }
    
    //
    // TurokAI::TweenLeftTurn
    //
    
    void TweenLeftTurn(void) {
        switch(ai.GetAIState()) {
            case AIS_IDLE:
                self.AnimState().Blend(anim_aiTurn_L_Stand, 4.0f, 8.0f, ANF_ROOTMOTION);
                break;
                
            case AIS_CALM:
                self.AnimState().Blend(anim_aiTurn_L_Walk, 4.0f, 8.0f, ANF_ROOTMOTION);
                break;
                
            case AIS_ALERT:
                self.AnimState().Blend(anim_aiTurn_L_Run, 4.0f, 8.0f, ANF_ROOTMOTION);
                break;
                
            default:
                return;
        }
        
        ai.bAnimTurning = true;
    }
    
    //
    // TurokAI::TweenRightTurn
    //
    
    void TweenRightTurn(void) {
        switch(ai.GetAIState()) {
            case AIS_IDLE:
                self.AnimState().Blend(anim_aiTurn_R_Stand, 4.0f, 8.0f, ANF_ROOTMOTION);
                break;
                
            case AIS_CALM:
                self.AnimState().Blend(anim_aiTurn_R_Walk, 4.0f, 8.0f, ANF_ROOTMOTION);
                break;
                
            case AIS_ALERT:
                self.AnimState().Blend(anim_aiTurn_R_Run, 4.0f, 8.0f, ANF_ROOTMOTION);
                break;
                
            default:
                return;
        }
        
        ai.bAnimTurning = true;
    }
    
    //
    // TurokAI::TweenBackTurn
    //
    
    void TweenBackTurn(void) {
        switch(ai.GetAIState()) {
            case AIS_IDLE:
                self.AnimState().Blend(anim_aiTurn_B_Stand, 4.0f, 8.0f, ANF_ROOTMOTION);
                break;
                
            case AIS_CALM:
                self.AnimState().Blend(anim_aiTurn_B_Walk, 4.0f, 8.0f, ANF_ROOTMOTION);
                break;
                
            case AIS_ALERT:
                self.AnimState().Blend(anim_aiTurn_B_Run, 4.0f, 8.0f, ANF_ROOTMOTION);
                break;
                
            default:
                return;
        }
        
        ai.bAnimTurning = true;
    }
    
    //
    // TurokAI::TweenFrontTurn
    //
    
    void TweenFrontTurn(const float angle) {
        switch(ai.GetAIState()) {
            case AIS_IDLE:
                self.AnimState().Blend(anim_aiStanding, 4.0f, 8.0f, ANF_ROOTMOTION|ANF_LOOP);
                break;
                
            case AIS_CALM:
            case AIS_ALERT:
                {
                    const float an4 = DegToRad(4.0f);
                    float time = 0;
                    
                    if(!(angle <= an4 && angle >= -an4)) {
                        kActor @targ = self.GetTarget();
                        if(!(targ is null)) {
                            float dist = self.GetOrigin().Distance(targ.GetOrigin()) / 384.0f;
                            time = 1.7f - dist * 0.7f;
                        }
                    }
                    
                    if(time < 0) {
                        time = 0;
                    }
                    
                    ai.yawSpeed = baseYawSpeed + time;
                    
                    if(ai.GetAIState() == AIS_CALM) {
                        self.AnimState().Blend(anim_aiWalking, 4.0f, 8.0f, ANF_ROOTMOTION|ANF_LOOP);
                    }
                    else {
                        self.AnimState().Blend(anim_aiRunning, 4.0f, 8.0f, ANF_ROOTMOTION|ANF_LOOP);
                        self.AnimState().frameTime = 4.0f - time;
                    }
                }
                break;
                
            default:
                return;
        }
    }
    
    //
    // TurokAI::ShouldKeepTurning
    //
    
    bool ShouldKeepTurning(void) {
        const int state = ai.GetAIState();
        
        if(state != AIS_CALM && state != AIS_ALERT) {
            return false;
        }
        
        const float angle = ai.GetYawToTarget();
        const float an45 = DegToRad(50.0f);
        
        if(angle > an45 || angle < -an45) {
            ai.aiFlags &= ~AIF_TURNING;
            
            if(angle < 0) {
                TweenLeftTurn();
                return true;
            }
            else {
                TweenRightTurn();
                return true;
            }
        }
        
        return false;
    }
    
    //
    // TurokAI::PlayingTurnAnimation
    //
    
    bool PlayingTurnAnimation(void) {
        return (self.AnimState().IsPlaying(anim_aiTurn_L_Stand) ||
                self.AnimState().IsPlaying(anim_aiTurn_R_Stand) ||
                self.AnimState().IsPlaying(anim_aiTurn_B_Stand) ||
                self.AnimState().IsPlaying(anim_aiTurn_L_Walk)  ||
                self.AnimState().IsPlaying(anim_aiTurn_R_Walk)  ||
                self.AnimState().IsPlaying(anim_aiTurn_B_Walk)  ||
                self.AnimState().IsPlaying(anim_aiTurn_L_Run)   ||
                self.AnimState().IsPlaying(anim_aiTurn_R_Run)   ||
                self.AnimState().IsPlaying(anim_aiTurn_B_Run));
    }
    
    //
    // TurokAI::OnTurn
    //
    
    bool OnTurn(const float angle) {
        const float an45 = DegToRad(50.0f);
        const float an150 = DegToRad(150.0f);

        if(PlayingTurnAnimation()) {
            return false;
        }
        
        if((self.AnimState().flags & ANF_BLEND) != 0) {
            return false;
        }

        if(angle > an150 || angle < -an150) {
            ai.aiFlags &= ~AIF_TURNING;
            
            TweenBackTurn();
            return false;
        }
        else if(angle > an45 || angle < -an45) {
            ai.aiFlags &= ~AIF_TURNING;
            
            if(angle < 0) {
                TweenLeftTurn();
                return false;
            }
            else {
                TweenRightTurn();
                return false;
            }
        }
        else {
            if((ai.aiFlags & AIF_SEETARGET != 0)) {
                TweenFrontTurn(angle);
            }
            else if(ai.bAnimTurning == false) {
                OnStateChange(ai.GetAIState());
            }
        }
        
        return true;
    }
    
    //
    // TurokAI::OnDeath
    //
    
    void OnDeath(kActor@ killer, kKeyMapMem @damageDef) {
        if(ai.aiState == AIS_DEATH || (ai.aiFlags & AIF_DISABLED) != 0) {
            return;
        }
        
        const array<int> anims = {
            anim_aiDeathStand,
            anim_aiDeathViolent,
            anim_aiDeathRunning
        };
        
        const array<int> weights = {
            18, 3, 8
        };
        
        PickAnimSet(anims, weights);
        ai.aiFlags |= AIF_DISABLED;
        ai.aiState = AIS_DEATH;
    }
    
    //
    // TurokAI::OnDormant
    //
    
    void OnDormant(void) {
        self.AnimState().Blend(anim_aiStanding, 4.0f, 4.0f, ANF_LOOP);
        ai.ClearTargets();
    }
    
    //
    // TurokAI::OnWake
    //
    
    void OnWake(void) {
        ai.ClearTargets();
    }
    
    //
    // TurokAI::OnLocalThink
    //
    
    void OnLocalThink(void) {
        if(ai.GetAIState() == AIS_DEATH) {
            if(bDeathFade == false) {
                if((self.AnimState().flags & ANF_STOPPED) != 0) {
                    deathFadeTime = 10.0f;
                    bDeathFade = true;
                }
            }
            else if(deathFadeTime > 0.0f) {
                float rt = Client.GetRunTime();
                deathFadeTime -= rt;
                
                if(deathFadeTime <= 5.0f) {
                    float scaleXZ = (1.0f - ((deathFadeTime / 5.0f) * -0.5f)) * (rt * 1.5f);
                    float scaleY = (1.0f - ((deathFadeTime / 5.0f))) * (rt * 1.5f);
                    
                    self.GetScale().x += (scaleXZ * scaleXZ);
                    self.GetScale().y += (scaleY * scaleY);
                    self.GetScale().z += (scaleXZ * scaleXZ);
                    
                    self.UpdateTransform();
                }
            }
            else {
                self.bHidden = true;
                self.Remove();
            }
        }
    }
    
    //
    // TurokAI::OnThink
    //
    
    void OnThink(void) {
    }
    
    //
    // TurokAI::OnSpawn
    //
    
    void OnSpawn(void) {
        int dropFlags1 = 0;
        int dropFlags2 = 0;
        
        if(!(self.def is null)) {
            self.def.GetInt("alligenceID", alligenceID);
            self.def.GetInt("dropItemFlags", dropFlags1);
            self.def.GetFloat("yawSpeed", baseYawSpeed);
        }
        
        self.args.GetInt("dropItemFlags", dropFlags2);
        
        dropItemFlags |= (dropFlags1 | dropFlags2);
    }
    
    //
    // TurokAI::OnTouch
    //
    
    bool OnTouch(kActor @instigator) {
        return true;
    }
    
    //
    // TurokAI::OnTrigger
    //
    
    void OnTrigger(void) {
    }
}
